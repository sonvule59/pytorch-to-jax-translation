[
  {
    "id": "e1.py",
    "language": "python",
    "code": "import torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# Generate synthetic data\ntorch.manual_seed(42)\nX = torch.rand(100, 1) * 10  # 100 data points between 0 and 10\ny = 2 * X + 3 + torch.randn(100, 1)  # Linear relationship with noise\n\n# Define the Linear Regression Model\nclass LinearRegressionModel(nn.Module):\n    def __init__(self):\n        super(LinearRegressionModel, self).__init__()\n        self.linear = nn.Linear(1, 1)  # Single input and single output\n\n    def forward(self, x):\n        return self.linear(x)\n\n# Initialize the model, loss function, and optimizer\nmodel = LinearRegressionModel()\ncriterion = nn.MSELoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01)\n\n# Training loop\nepochs = 1000\nfor epoch in range(epochs):\n    # Forward pass\n    predictions = model(X)\n    loss = criterion(predictions, y)\n\n    # Backward pass and optimization\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n\n    # Log progress every 100 epochs\n    if (epoch + 1) % 100 == 0:\n        print(f\"Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.4f}\")\n\n# Display the learned parameters\n[w, b] = model.linear.parameters()\nprint(f\"Learned weight: {w.item():.4f}, Learned bias: {b.item():.4f}\")\n\n# Testing on new data\nX_test = torch.tensor([[4.0], [7.0]])\nwith torch.no_grad():\n    predictions = model(X_test)\n    print(f\"Predictions for {X_test.tolist()}: {predictions.tolist()}\")",
    "translated_code": "# Translation failed: invalid output"
  },
  {
    "id": "e2.py",
    "language": "python",
    "code": "import torch\nimport pandas as pd\n\ntorch.manual_seed(42)\nX = torch.rand(100, 1) * 10  # 100 data points between 0 and 10\ny = 2 * X + 3 + torch.randn(100, 1)  # Linear relationship with noise\n\n# Save the generated data to data.csv\ndata = torch.cat((X, y), dim=1)\ndf = pd.DataFrame(data.numpy(), columns=['X', 'y'])\ndf.to_csv('data.csv', index=False)\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nimport pandas as pd\n\nclass LinearRegressionDataset(Dataset):\n    def __init__(self, csv_file):\n        # Load data from CSV file\n        self.data = pd.read_csv(csv_file)\n        self.X = torch.tensor(self.data['X'].values, dtype=torch.float32).view(-1, 1)\n        self.y = torch.tensor(self.data['y'].values, dtype=torch.float32).view(-1, 1)\n    \n    def __len__(self):\n        return len(self.data)\n    \n    def __getitem__(self, idx):\n        return self.X[idx], self.y[idx]\n\n# Example usage of the DataLoader\ndataset = LinearRegressionDataset('data.csv')\ndataloader = DataLoader(dataset, batch_size=32, shuffle=True)\n\n# Define the Linear Regression Model\nclass LinearRegressionModel(nn.Module):\n    def __init__(self):\n        super(LinearRegressionModel, self).__init__()\n        self.linear = nn.Linear(1, 1)  # Single input and single output\n\n    def forward(self, x):\n        return self.linear(x)\n\n# Initialize the model, loss function, and optimizer\nmodel = LinearRegressionModel()\ncriterion = nn.MSELoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01)\n\n# Training loop\nepochs = 1000\nfor epoch in range(epochs):\n    for batch_X, batch_y in dataloader:\n        # Forward pass\n        predictions = model(batch_X)\n        loss = criterion(predictions, batch_y)\n\n        # Backward pass and optimization\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n\n    # Log progress every 100 epochs\n    if (epoch + 1) % 100 == 0:\n        print(f\"Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.4f}\")\n\n# Display the learned parameters\n[w, b] = model.linear.parameters()\nprint(f\"Learned weight: {w.item():.4f}, Learned bias: {b.item():.4f}\")\n\n# Testing on new data\nX_test = torch.tensor([[4.0], [7.0]])\nwith torch.no_grad():\n    predictions = model(X_test)\n    print(f\"Predictions for {X_test.tolist()}: {predictions.tolist()}\")",
    "translated_code": "# Translation failed: invalid output"
  },
  {
    "id": "e3.py",
    "language": "python",
    "code": "import torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom matplotlib import pyplot as plt\n\n# Generate synthetic data\ntorch.manual_seed(42)\nX = torch.rand(100, 1) * 10  # 100 data points between 0 and 10\ny = 2 * X + 3 + torch.randn(100, 1)  # Linear relationship with noise\n\n# Define the Linear Regression Model within a CustomActivationModel class\nclass CustomActivationModel(nn.Module):\n    def __init__(self):\n        super(CustomActivationModel, self).__init__()\n        self.linear = nn.Linear(1, 1)  # Single input and single output\n\n    def custom_activation(self, x):\n        return torch.tanh(x) + x\n\n    def forward(self, x):\n        return self.custom_activation(self.linear(x))\n\n# Initialize the model, loss function, and optimizer\nmodel = CustomActivationModel()\ncriterion = nn.MSELoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01)\n\n# Training loop\nepochs = 1000\nfor epoch in range(epochs):\n    # Forward pass\n    predictions = model(X)\n    loss = criterion(predictions, y)\n\n    # Backward pass and optimization\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n\n    # Log progress every 100 epochs\n    if (epoch + 1) % 100 == 0:\n        print(f\"Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.4f}\")\n\n# Display the learned parameters\n[w, b] = model.linear.parameters()\nprint(f\"Learned weight: {w.item():.4f}, Learned bias: {b.item():.4f}\")\n\n# Plot the model fit to the train data\nplt.figure(figsize=(4, 4))\nplt.scatter(X, y, label='Training Data')\nplt.plot(X, w.item()*X + b.item(), 'r', label='Model Fit')\nplt.legend()\nplt.show()\n\n# Testing on new data\nX_test = torch.tensor([[4.0], [7.0]])\nwith torch.no_grad():\n    predictions = model(X_test)\n    print(f\"Predictions for {X_test.tolist()}: {predictions.tolist()}\")\n\n    ",
    "translated_code": "# Translation failed: invalid output"
  },
  {
    "id": "e4.py",
    "language": "python",
    "code": "import torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# Generate synthetic data\ntorch.manual_seed(42)\nX = torch.rand(100, 1) * 10  # 100 data points between 0 and 10\ny = 2 * X + 3 + torch.randn(100, 1)  # Linear relationship with noise\n\n\nclass HuberLoss(nn.Module):\n    def __init__(self, delta=1.0):\n        super(HuberLoss, self).__init__()\n        self.delta = delta\n    \n    def forward(self, y_pred, y_true):\n        # Calculate the absolute error\n        error = torch.abs(y_pred - y_true)\n        \n        # Apply the Huber loss formula\n        loss = torch.where(error <= self.delta,\n                           0.5 * error**2,  # L2 loss for small errors\n                           self.delta * (error - 0.5 * self.delta))  # L1 loss for large errors\n        return loss.mean()  # Return the mean loss across all samples\n\n\n# Define the Linear Regression Model\nclass LinearRegressionModel(nn.Module):\n    def __init__(self):\n        super(LinearRegressionModel, self).__init__()\n        self.linear = nn.Linear(1, 1)  # Single input and single output\n\n    def forward(self, x):\n        return self.linear(x)\n\n# Initialize the model, loss function, and optimizer\nmodel = LinearRegressionModel()\ncriterion = HuberLoss(delta=1.0)\noptimizer = optim.SGD(model.parameters(), lr=0.01)\n\n# Training loop\nepochs = 1000\nfor epoch in range(epochs):\n    # Forward pass\n    predictions = model(X)\n    loss = criterion(predictions, y)\n\n    # Backward pass and optimization\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n\n    # Log progress every 100 epochs\n    if (epoch + 1) % 100 == 0:\n        print(f\"Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.4f}\")\n\n# Display the learned parameters\n[w, b] = model.linear.parameters()\nprint(f\"Learned weight: {w.item():.4f}, Learned bias: {b.item():.4f}\")\n\n# Testing on new data\nX_test = torch.tensor([[4.0], [7.0]])\nwith torch.no_grad():\n    predictions = model(X_test)\n    print(f\"Predictions for {X_test.tolist()}: {predictions.tolist()}\")",
    "translated_code": "# Translation failed: invalid output"
  },
  {
    "id": "e5.py",
    "language": "python",
    "code": "import torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# Generate synthetic data\ntorch.manual_seed(42)\nX = torch.rand(100, 2) * 10  # 100 data points with 2 features\ny = (X[:, 0] + X[:, 1] * 2).unsqueeze(1) + torch.randn(100, 1)  # Non-linear relationship with noise\n\n# Define the Deep Neural Network Model\nclass DNNModel(nn.Module):\n    def __init__(self):\n        super(DNNModel, self).__init__()\n        self.fc1 = nn.Linear(2, 10)  # Input layer to hidden layer\n        self.relu = nn.ReLU()       # Activation function\n        self.fc2 = nn.Linear(10, 1) # Hidden layer to output layer\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.fc2(x)\n        return x\n    \n# Initialize the model, loss function, and optimizer\nmodel = DNNModel()\ncriterion = nn.MSELoss()\noptimizer = optim.Adam(model.parameters(), lr=0.01)\n\n# Training loop\nepochs = 1000\nfor epoch in range(epochs):\n    # Forward pass\n    predictions = model(X)\n    loss = criterion(predictions, y)\n\n    # Backward pass and optimization\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n\n    # Log progress every 100 epochs\n    if (epoch + 1) % 100 == 0:\n        print(f\"Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.4f}\")\n\n# Testing on new data\nX_test = torch.tensor([[4.0, 3.0], [7.0, 8.0]])\nwith torch.no_grad():\n    predictions = model(X_test)\n    print(f\"Predictions for {X_test.tolist()}: {predictions.tolist()}\")\n    ",
    "translated_code": "# Translation failed: invalid output"
  },
  {
    "id": "e6.py",
    "language": "python",
    "code": "import torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.utils.tensorboard import SummaryWriter\n\n# Generate synthetic data\ntorch.manual_seed(42)\nX = torch.rand(100, 1) * 10  # 100 data points between 0 and 10\ny = 3 * X + 5 + torch.randn(100, 1)  # Linear relationship with noise\n\n# Define a simple Linear Regression Model\nclass LinearRegressionModel(nn.Module):\n    def __init__(self):\n        super(LinearRegressionModel, self).__init__()\n        self.linear = nn.Linear(1, 1)  # Single input and single output\n\n    def forward(self, x):\n        return self.linear(x)\n\n# Initialize TensorBoard writer\nwriter = SummaryWriter(log_dir=\"runs/linear_regression\")\n\n# Initialize the model, loss function, and optimizer\nmodel = LinearRegressionModel()\ncriterion = nn.MSELoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01)\n\n# Training loop\nepochs = 100\nfor epoch in range(epochs):\n    # Forward pass\n    predictions = model(X)\n    loss = criterion(predictions, y)\n\n    # Backward pass and optimization\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n\n    # Log loss to TensorBoard\n    writer.add_scalar(\"Loss/train\", loss.item(), epoch)\n\n    # Log progress every 10 epochs\n    if (epoch + 1) % 10 == 0:\n        print(f\"Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.4f}\")\n\n# Close the TensorBoard writer\nwriter.close()\n\n# Run TensorBoard using the logs generated\n# Command to run: tensorboard --logdir=runs",
    "translated_code": "# Translation failed: invalid output"
  },
  {
    "id": "e7.py",
    "language": "python",
    "code": "import torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# Define a simple model\nclass SimpleModel(nn.Module):\n    def __init__(self):\n        super(SimpleModel, self).__init__()\n        self.fc = nn.Linear(1, 1)\n\n    def forward(self, x):\n        return self.fc(x)\n\n# Create and train the model\ntorch.manual_seed(42)\nmodel = SimpleModel()\ncriterion = nn.MSELoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01)\n\n# Training loop\nX = torch.rand(100, 1)\ny = 3 * X + 2 + torch.randn(100, 1) * 0.1\nepochs = 100\nfor epoch in range(epochs):\n    optimizer.zero_grad()\n    predictions = model(X)\n    loss = criterion(predictions, y)\n    loss.backward()\n    optimizer.step()\n\n# Save the model to a file named \"model.pth\"\ntorch.save(model.state_dict(), \"model.pth\")\n\n# Load the model back from \"model.pth\"\nloaded_model = SimpleModel()\nloaded_model.load_state_dict(torch.load(\"model.pth\"))\nloaded_model.eval()\n\n# Verify the model works after loading\nX_test = torch.tensor([[0.5], [1.0], [1.5]])\nwith torch.no_grad():\n    predictions = loaded_model(X_test)\n    print(f\"Predictions after loading: {predictions}\")\n    ",
    "translated_code": "# Translation failed: invalid output"
  },
  {
    "id": "h1.py",
    "language": "python",
    "code": "import torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# Generate synthetic data\ntorch.manual_seed(42)\nX = torch.rand(100, 1) * 10  # 100 data points between 0 and 10\ny = 2 * X + 3 + torch.randn(100, 1)  # Linear relationship with noise\n\nclass LearnedSiLUFunction(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx, x, slope):\n        # Save the input tensor and slope for backward computation\n        ctx.save_for_backward(x)\n        ctx.slope = slope\n        return slope * x * torch.sigmoid(x)\n\n    @staticmethod\n    def backward(ctx, grad_output):\n        # Retrieve the input and slope saved in the forward pass\n        x, = ctx.saved_tensors\n        slope = ctx.slope\n        sigmoid_x = torch.sigmoid(x)\n\n        # Compute the gradient with respect to input (x)\n        grad_input = grad_output * slope * (sigmoid_x + x * sigmoid_x * (1 - sigmoid_x))\n\n        # Compute the gradient with respect to slope\n        grad_slope = grad_output * x * sigmoid_x\n\n        return grad_input, grad_slope\n\n\n# Define the Linear Regression Model\nclass LinearRegressionModel(nn.Module):\n    def __init__(self, slope=1):\n        super().__init__()\n        self.slope = nn.Parameter(torch.ones(1) * slope)\n\n    def forward(self, x):\n        # Use the custom LearnedSiLUFunction\n        return LearnedSiLUFunction.apply(x, self.slope)\n\n# Initialize the model, loss function, and optimizer\nmodel = LinearRegressionModel()\ncriterion = nn.MSELoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01)\n\n# Training loop\nepochs = 1000\nfor epoch in range(epochs):\n    # Forward pass\n    predictions = model(X)\n    loss = criterion(predictions, y)\n\n    # Backward pass and optimization\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n\n    # Log progress every 100 epochs\n    if (epoch + 1) % 100 == 0:\n        print(f\"Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.4f}\")\n\n# Display the learned parameters\n[w, b] = model.linear.parameters()\nprint(f\"Learned weight: {w.item():.4f}, Learned bias: {b.item():.4f}\")\n\n# Testing on new data\nX_test = torch.tensor([[4.0], [7.0]])\nwith torch.no_grad():\n    predictions = model(X_test)\n    print(f\"Predictions for {X_test.tolist()}: {predictions.tolist()}\")",
    "translated_code": "# Translation failed: invalid output"
  },
  {
    "id": "h10.py",
    "language": "python",
    "code": "# Explain a CNN model's predictions using Grad-CAM in PyTorch\nimport torch\nimport torch.nn as nn\nimport torchvision.models as models\nimport torchvision.transforms as transforms\nimport torchvision.datasets as datasets\nfrom PIL import Image\nimport matplotlib.pyplot as plt\n\n# Load a pre-trained ResNet model\nmodel = models.resnet18(pretrained=True)\nmodel.eval()\n\n# Define variables to capture gradients and activations\ngradients = None\nactivations = None\n\n# Define hooks to capture gradients and activations\ndef save_gradients(module, grad_in, grad_out):\n    global gradients\n    gradients = grad_out[0]\n\ndef save_activations(module, input, output):\n    global activations\n    activations = output\n\n# Attach hooks to the target layer\ntarget_layer = model.layer4[1].conv2\ntarget_layer.register_backward_hook(save_gradients)\ntarget_layer.register_forward_hook(save_activations)\n\n# Fetch a sample image from torchvision datasets\ndataset = datasets.FakeData(transform=transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n]))\nimage, _ = dataset[0]  # Get the first image\nimage = transforms.ToPILImage()(image)  # Convert to PIL for visualization\n\n# Preprocess the image for the model\npreprocess = transforms.Compose([\n    transforms.Resize((224, 224)),\n    transforms.ToTensor(),\n    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n])\ninput_tensor = preprocess(image).unsqueeze(0)\n\n# Perform a forward pass\noutput = model(input_tensor)\npredicted_class = output.argmax(dim=1).item()\n\n# Perform a backward pass for the predicted class\nmodel.zero_grad()\noutput[0, predicted_class].backward()\n\n# Generate Grad-CAM heatmap\nweights = gradients.mean(dim=[2, 3], keepdim=True)\nheatmap = (weights * activations).sum(dim=1).squeeze().relu()\n\n# Normalize the heatmap and overlay it on the original image\nheatmap = heatmap / heatmap.max()\nheatmap = transforms.ToPILImage()(heatmap.cpu())\nheatmap = heatmap.resize(image.size, resample=Image.BILINEAR)\n\n# Display the image with the Grad-CAM heatmap\nplt.imshow(image)\nplt.imshow(heatmap, alpha=0.5, cmap='jet')\nplt.title(f\"Predicted Class: {predicted_class}\")\nplt.axis('off')\nplt.show()\n",
    "translated_code": "# Translation failed: invalid output"
  },
  {
    "id": "h3.py",
    "language": "python",
    "code": "import torch\nimport torch.nn as nn\nimport torch.optim as optim\n\n# Define a Transformer Model\nclass TransformerModel(nn.Module):\n    def __init__(self, input_dim, embed_dim, num_heads, num_layers, ff_dim, output_dim):\n        super(TransformerModel, self).__init__()\n        self.embedding = nn.Linear(input_dim, embed_dim)\n        encoder_layer = nn.TransformerEncoderLayer(d_model=embed_dim, nhead=num_heads, dim_feedforward=ff_dim)\n        self.transformer = nn.TransformerEncoder(encoder_layer, num_layers=num_layers)\n        self.output_layer = nn.Linear(embed_dim, output_dim)\n\n    def forward(self, x):\n        x = self.embedding(x)\n        x = self.transformer(x)\n        x = x.mean(dim=1)  # Pooling across the sequence\n        return self.output_layer(x)\n    \n# Generate synthetic data\ntorch.manual_seed(42)\nseq_length = 10\nnum_samples = 100\ninput_dim = 1\nX = torch.rand(num_samples, seq_length, input_dim)  # Random sequences\ny = torch.sum(X, dim=1)  # Target is the sum of each sequence\n\n# Initialize the model, loss function, and optimizer\ninput_dim = 1\nembed_dim = 16\nnum_heads = 2\nnum_layers = 2\nff_dim = 64\noutput_dim = 1\n\nmodel = TransformerModel(input_dim, embed_dim, num_heads, num_layers, ff_dim, output_dim)\ncriterion = nn.MSELoss()\noptimizer = optim.Adam(model.parameters(), lr=0.001)\n\n# Training loop\nepochs = 1000\nfor epoch in range(epochs):\n    # Forward pass\n    predictions = model(X)\n    loss = criterion(predictions, y)\n\n    # Backward pass and optimization\n    optimizer.zero_grad()\n    loss.backward()\n    optimizer.step()\n\n    # Log progress every 100 epochs\n    if (epoch + 1) % 100 == 0:\n        print(f\"Epoch [{epoch + 1}/{epochs}], Loss: {loss.item():.4f}\")\n\n# Testing on new data\nX_test = torch.rand(2, seq_length, input_dim)\nwith torch.no_grad():\n    predictions = model(X_test)\n    print(f\"Predictions for {X_test.tolist()}: {predictions.tolist()}\")",
    "translated_code": "# Translation failed: invalid output"
  }
]